# 2.2 Ενθυλάκωση {#Java} 
© Γιάννης Κωστάρας

---

[<-](../2.2-UML/README.md) | [Δ](../../README.md) | [->](../2.4-Inheritance/README.md)

---

## Ενθυλάκωση

Ένα από τα πολλά προβλήματα που υπήρχαν με το διαδικαστικό μοντέλο προγραμματισμού ήταν ότι υπήρχε πρόσβαση χωρίς κάποιον έλεγχο στις καθολικές μεταβλητές, δηλ. οποιοδήποτε τμήμα του προγράμματος μπορούσε να τις αλλάξει. Αυτό καθιστούσε πολύ δύσκολη την αποσφαλμάτωση, όταν εμφανίζονταν bugs που οφείλονταν στη μεταβολή των καθολικών μεταβλητών.

Το αντικειμενοστραφές μοντέλο έφερε περιορισμούς στην πρόσβαση των δεδομένων. Έτσι, πλέον, οι μεταβλητές ορίζονται και χρησιμοποιούνται μόνο από το τμήμα κώδικα που χρειάζεται. Επίσης τα δεδομένα ορίζονται πλέον μαζί με τις μεθόδους που τις αλλάζουν, δηλ. μέσα στις κλάσεις, όπως είδαμε στο προηγούμενο μάθημα. 

Η ενθυλάκωση:

* επιτρέπει τον έλεγχο πρόσβασης στα δεδομένα ενός αντικειμένου μόνο μέσω από τις μεθόδους του
* η χρήση του αντικειμένου δεν αλλάζει αν αλλάξουν τα δεδομένα

Πώς επιτυγχάνεται η ενθυλάκωση; Η Java παρέχει κάποιες δεσμευμένες λέξεις για το σκοπό αυτό:

* ```public``` σημαίνει ότι το γνώρισμα ή η μέθοδος ή η κλάση μπορούν να προσπελαστούν από άλλες κλάσεις (η πρόσβαση είναι ανοικτή σε όλους)
* ```private``` σημαίνει ότι το γνώρισμα ή η μέθοδος ή η κλάση μπορούν να προσπελαστούν μόνο από την ίδια κλάση

Υπάρχουν δυο ακόμα τρόποι πρόσβασης που θα δούμε στις επόμενες διαλέξεις, αλλά τις αναφέρουμε εδώ για πληρότητα:

* ```package``` σημαίνει ότι το γνώρισμα ή η μέθοδος ή η κλάση μπορούν να προσπελαστούν από άλλες κλάσεις που ανήκουν στο ίδιο πακέτο (package) με την εν λόγω κλάση
* ```protected``` σημαίνει ότι το γνώρισμα ή η μέθοδος ή η κλάση μπορούν να προσπελαστούν από τις υποκλάσεις της εν λόγω κλάσης

Συνήθως τα δεδομένα χαρακτηρίζονται σχεδόν πάντα ως ```private``` (ή ```protected```) και οι μέθοδοι που επιτρέπουν πρόσβαση σ' αυτά τα δεδομένα ως ```public```.

Τα παραπάνω συνοψίζονται στον παρακάτω πίνακα:

| Τροποποιητής πρόσβασης | Ίδια κλάση | Ίδιο πακέτο | Υποκλάση | Άλλα πακέτα |
| ```public``` | X | X | X | X |
| ```protected``` | X | X | X | |
| ```package``` ή τίποτα | X | X | | |
| ```private``` | X | | | |

Ας δούμε πώς θα έπρεπε να είχαμε γράψει τη κλάση ```Car``` της προηγούμενης διάλεξης, κάνοντας σωστή χρήση της ενθυλάκωσης.
  
```java
public class Car { // κλάση
  // ιδιότητες/γνωρίσματα
  private String model;
  private int maxSpeed;
  private int ccm;
  private int speed = 0;
  // μέθοδος δημιουργίας αντικειμένων - κατασκευαστής
  public Car(String m, int s, int c) {
    model = m; maxSpeed = s; ccm = c;
  }
  // ενέργειες/μέθοδοι
  public void accelerate() {
     if (speed <= maxSpeed - 10)
        speed+=10;
  }
  public void decelerate() {
     if (speed >= 10)
        speed-=10;
  }  
  public String getModel() {
  	return model;
  }
  public int getMaxSpeed() {
  	return maxSpeed;
  }
  public int getCcm() {
  	return ccm;
  }
  public int getSpeed() {
  	return speed;
  }
}
```

Πλέον έχουμε ενθυλακώσει τα γνωρίσματα της κλάσης ορίζοντάς τα ως ```private``` και την κλάση και τις μεθόδους της ως ```public``` πράγμα που σημαίνει ότι είναι προσβάσιμες από οποιαδήποτε άλλη κλάση του προγράμματος.

```bash
// Αντικείμενα
jshell> Car audiA3 = new Car("Audi A3", 210, 1595);
audiA3 ==> Car@6d00a15d
jshell> audiA3.speed
|  Error:
|  speed has private access in Car
|  audiA3.speed
|  ^----------^
jshell> audiA3.getSpeed()
$1 ==> 0
jshell> audiA3.accelerate();
jshell> audiA3.getSpeed()
$2 ==> 10
```

Πλέον δεν μπορούμε να καλέσουμε το γνώρισμα ```speed``` της κλάσης ```Car``` καθώς η πρόσβαση σ' αυτό έχει οριστεί ως ```private```. Θα πρέπει να χρησιμοποιήσουμε την αντίστοιχη μέθοδο ```get``` για να προσπελάσουμε το γνώρισμα. Το γνώρισμα έχει πλέον ενθυλακωθεί στην κλάση και δεν είναι προσβάσιμο πέραν των αντικειμένων της κλάσης.

Είναι καλή τακτική να περιορίζεται όσο γίνεται την πρόσβαση στα γνωρίσματα, τις μεθόδους και τις κλάσεις. Π.χ. αν γνωρίζετε ότι μια μέθοδος θα καλείται μόνο μέσα από την κλάση, τότε καλό είναι να την ορίσετε ως ```private```. Μια κλάση που θα καλείται μόνο από κλάσεις από το ίδιο πακέτο στο οποίο ανήκει, καλό είναι να ορίζεται με τον εξ' ορισμού τροποποιητή (δηλ. ```package```).

Στη UML, ο τροποποιητής πρόσβασης ```private``` αναπαρίσταται με το ```-```, η ```public``` με το ```+```, η ```protected``` με ```#``` ενώ η ```package``` με το ```~``` (βλ. εικόνα X του προηγούμενου μαθήματος).

## Βιβλιοθήκες (packages)
Οι τροποποιητές πρόσβασης είναι ένας τρόπος περιορισμού της πρόσβασης στις κλάσεις. Ένας άλλος είναι τα πακέτα (packages). Μπορούμε να ομαδοποιήσουμε τις κλάσεις σε πακέτα.

Π.χ.
```java
package utils;
public class Util {
   static double circumference(double radius) { ... }
   private void helper() { ... }
   public static area(double radius) { ... }
}
```

Αρκεί να χρησιμοποιήσουμε την λέξη-κλειδί ```package``` μαζί με το όνομα της βιβλιοθήκης, στην αρχή κάθε αρχείου, το οποίο θέλουμε να εντάξουμε στην βιβλιοθήκη. Καλό είναι να αποθηκεύσουμε τα αρχεία κλάσεων της βιβλιοθήκης σε έναν αντίστοιχο φάκελο του λειτουργικού συστήματος. Έτσι, η παραπάνω κλάση ```Util``` θα πρέπει να αποθηκευθεί σε ένα φάκελο ```utils```.

Τα ονόματα των βιβλιοθηκών ακολουθούν συνήθως την ονοματολογία των πεδίων διαδικτύου (internet domains) τα οποία θεωρούνται μοναδικά, π.χ.
```java
gr.mycompany.app                // αποθηκεύεται στη διαδρομή φακέλων gr/mycompany/app
gr.mycompany.app.model
gr.mycompany.app.view
gr.mycompany.app.controller
gr.mycompany.app.utils
```
Ο εξ' ορισμού τροποποιητής πρόσβασης επιτρέπει σε κλάσεις του πακέτου να έχουν πρόσβαση σε άλλες κλάσεις του ίδιου πακέτου. Π.χ.

```java
package utils;
class Helper {
   void prettyPrint(String... s) { ... }
}
private class Secret {

}
```
Η κλάση Helper μπορεί να έχει πρόσβαση στις μεθόδους ```circumference()``` και ```area()``` της κλάσης ```Util``` αλλά όχι και στη ```helper()``` η οποία είναι ```private```. Αντίστοιχα η ```Util``` μπορεί να προσπελάσει την κλάση ```Helper``` και τη μέθοδό της ```prettyPrint()``` αλλά όχι τη ```Secret```.

Αν η κλάση που θέλουμε να χρησιμοποιήσουμε ανήκει σε κάποια άλλη βιβλιοθήκη, τότε μπορούμε να την εισάγουμε με την εντολή ```import```:
```java
import utils.*;
...
Util.circumference(12.0);  	// Error: έχει πρόσβαση package
Util.area(12.0);  			// OK: έχει πρόσβαση public
```
διαφορετικά αν δεν χρησιμοποιήσουμε την ```import```:
```java
utils.Util.area(12.0);  			
```

Με τη χρήση στατικής εισαγωγής (static import) μπορούμε να κάνουμε χρήση των στατικών πεδίων μιας κλάσης, χωρίς να χρησιμοποιούμε το όνομα της κλάσης στην οποία ανήκουν. Μπορούμε να εισάγουμε τα στατικά μέλη μιας κλάσης χρησιμοποιώντας την ```import static```. Π.χ. 
```java
double radius = Math.sin(Math.PI * theta);
```
μπορεί να γραφτεί:
```java
import static java.lang.Math.*;
double radius = sin(PI * theta);
```

Ο διερμηνέας εντοπίζει τις κλάσεις μιας βιβλιοθήκης ως εξής:
* Πρώτα εντοπίζει και διαβάζει την μεταβλητή περιβάλλοντος ```CLASSPATH```, η οποία περιέχει μια σειρά από καταλόγους από τους οποίους μπορεί να ξεκινήσει την αναζήτηση των
κλάσεων. 
* Στη συνέχεια «επιλύει» το όνομα μιας βιβλιοθήκης σε όνομα καταλόγου του συστήματος
αρχείων. Π.χ.: το package foo.bar επιλύεται σε foo/bar
* Το όνομα του καταλόγου αυτού επικολλάται στα περιεχόμενα του ```CLASSPATH```, δημιουργώντας έτσι την ακριβή διεύθυνση στο σύστημα αρχείων απʼ όπου μπορούν να αναζητηθούν οι κλάσεις της βιβλιοθήκης.
• Σημειώστε ότι στο ```CLASSPATH``` πρέπει να έχετε τοποθετήσει και τον τρέχοντα κατάλογο ```.```.

Από την γραμμή εντολών θα πρέπει να ορίσουμε το ```CLASSPATH```:
```bash
java -cp .:util
```

jar files

Η UML διαθέτει τα διαγράμματα πακέτων (package diagrams). Στην παρακάτω εικόνα βλέπουμε ένα διάγραμμα πακέτων με 4 πακέτα καθώς και τις συσχετίσεις (dependencies) μεταξύ τους.

![](assets/Fig1.png)

**Εικόνα 1** _Παράδειγμα διαγράμματος πακέτων στη UML_

## Αρθρώματα (modules)
Προηγουμένως είδαμε πώς μπορούμε να περιορίσουμε την πρόσβαση σε άλλες κλάσεις χρησιμοποιώντας τα πακέτα ή/και τους τροποποιητές πρόσβασης. 

Ας υποθέσουμε ότι έχουμε τις εξής κλάσεις:
```java
package app.foo;
public class Foo {

}

package app.foo;
public class Bar {

}

package app.bla;
class Bla {

}
```
Θα θέλαμε η κλάση ```Foo``` να έχει πρόσβαση στην κλάση ```Bla``` αλλά όχι η κλάση ```Bar```. Ο μόνος τρόπος είναι ν' αλλάξουμε την κλάση ```Bla``` από πρόσβαση ```package``` σε ```public```. Έτσι θα μπορεί η κλάση ```Foo``` να έχει πρόσβαση στην ```Bla``` αλλά τότε όμως και η ```Bar``` θα έχει πρόσβαση στην ```Bla```. Πώς μπορούμε να το αποτρέψουμε αυτό; Δεν μπορούμε.
 
Από την έκδοση 9 και μετά, η γλώσσα εισήγαγε άλλο ένα επίπεδο ενθυλάκωσης, τα αρθρώματα (modules). Με τ'αρθρώματα η γλώσσα επιτρέπει τη δημιουργία προγραμμάτων με αρθρωτή αρχιτεκτονική (modular architecture), δηλ. συστημάτων με τα εξής χαρακτηριστικά:

* _Ενισχυμένη ενθυλάκωση (strong encapsulation)_: Ένα άρθρωμα πρέπει να μπορεί να αποκρύψει μέρος του κώδικα από άλλα αρθρώματα. Κατά συνέπεια, ενθυλακωμένος κώδικας μπορεί να αλλάξει ελεύθερα χωρίς να επηρρεάζει άλλα αρθρώματα.
* _Προκαθορισμένες διεπαφές (well defined interfaces)_: τα αρθρώματα θα πρέπει να ορίζουν καθορισμένες διεπαφές στα άλλα αρθρώματα.
* _Ρητές εξαρτήσεις (explicit dependencies)_: κατά τον ορισμό των αρθρωμάτων θα πρέπει να ορίζονται και οι εξαρτήσεις τους.

Ένα άρθρωμα έχει ένα όνομα (π.χ. ```java.base```), ομαδοποιεί σχετικό κώδικα και πόρους και περιγράφεται με έναν _περιγραφέα αρθρώματος (module descriptor)_. Ο περιγραφέας αρθρώματος είναι ένα αρχείο ```module-info.java``` (στο αρχικό πακέτο).

![](assets/Fig2.png)

**Εικόνα 2** _Περιγραφέας αρθρώματος (module descriptor)_

Στην παραπάνω εικόνα, δημιουργώντας το αρχείο ```module-info.java``` στον αρχικό κατάλογο του προγράμματος ```AnagramGame```, το μετατρέπουμε σε άρθρωμα. Το όνομά του είναι ```com.toy.anagrams```. Το άρθρωμα εκθέτει ένα από τα πακέτα του, το ```com.toy.anagrams.util```. Άλλα αρθρώματα μπορούν να προσπελάσουν μόνο αυτό το πακέτο του αρθρώματος. Επίσης, για να μπορεί να μεταγλωττιστεί και να εκτελεστεί το πρόγραμμα εξαρτάται από δυο ακόμα αρθρώματα τα ```java.logging``` και ```java.desktop```.

Με την ευκαιρία της υποστήριξης αρθρωμάτων, ολόκληρο το JDK από την έκδοση 9 και μετά έχει τμηματοποιηθεί σε αρθρώματα. 

![](assets/Fig3.png)

**Εικόνα 3** _Το JDK 9 τμηματοποιημένο σε αρθρώματα_

Το JDK 9 έχει τμηματοποιηθεί σε 90 αρθρώματα. Το άρθρωμα ```java.base``` είναι το βασικό άρθρωμα που εισάγεται εξ' ορισμού σε όλα τα προγράμματα Java. Εκθέτει διάφορες βασικές βιβλιοθήκες όπως ```java.lang``` και ```java.util```. Από εκεί και πέρα μπορείτε να προσθέσετε μόνο τα αρθρώματα που χρειάζεστε για την εφαρμογή σας. Π.χ. αν χτίζετε μια εφαρμογή desktop, προσθέστε μια εξάρτηση στο άρθρωμα ```java.desktop``` κλπ.

To NetBeans 9 υποστηρίζει modules.

![](assets/Fig4.png)

**Εικόνα 4** _Δημιουργία αρθρώματος με το NetBeans_

![](assets/Fig5.png)

**Εικόνα 5** _Γραφική αναπαράσταση εξαρτήσεων από το NetBeans_

```
module AnagramGame {
	requires java.logging;
	requires java.desktop;
	exports com.toy.anagrams.lib;
}
```

Στο παραπάνω παράδειγμα βλέπουμε ότι το άρθρωμά μας ```AnagramGame``` διαθέτει εξαρτήσεις σε δυο αρθρώματα της Java και εξάγει ένα πακέτο της προς διάθεση σε άλλα αρθρώματα. Εξάγοντας ένα πακέτο σημαίνει απλά ότι άλλα πακέτα έχουν πρόσβαση στα ```public``` (ή ```package```) τμήματα (κλάσεις, μεθόδους, υπο-πακέτα κλπ.) του πακέτου. Δηλαδή, οι κανόνες πρόσβασης σε επίπεδο κλάσης, πακέτου κλπ. συνεχίζουν να ισχύουν.

Γενικά ισχύουν οι ακόλουθες λέξεις-κλειδιά σ' ένα άρθρωμα:

* _exports_: Εξάγει (εκθέτει) ένα πακέτο
* _opens_: επιτρέπει τη χρήση reflection στις κλάσεις του πακέτου
* _provides_: Παρέχει έναν service provider
* _requires_: Ορίζει μια εξάρτηση σ' ένα άλλο πακέτο
* _uses_: Χρησιμοποιεί μια υπηρεσία

![](assets/Fig6.png)

**Εικόνα 6** _Απαγορεύονται οι κυκλικές εξαρτήσεις μεταξύ αρθρωμάτων_

Στη UML τα αρθρώματα μπορούν να αναπαρασταθούν ως υποσυστήματα (subsystems). Στο παράδειγμα της παρακάτων εικόνας βλέπουμε πως διάφοα υποσυστήματα (αρθρώματα) εξαρτώνται το ένα από το άλλο αλλά και πως εμφωλιάζουν (nest) άλλα πακέτα ή υποσυστήματα.

![](assets/Fig7.png)

**Εικόνα 7** _Παράδειγμα διαγράμματος αρθρωμάτων στη UML_

## Πηγές:
1. ["The Java Tutorial"](https://docs.oracle.com/javase/tutorial/)
1. Bloch J. (2018), _Effective Java_, 3rd Edition, Addison-Wesley.
1. Deitel P., Deitel H. (2018), _Java How to Program_, 11th Ed., Safari.
1. Downey A. B., Mayfield C. (2016), _Think Java_, O' Reilly. 
1. Eckel B. (2006), _Thinking in Java_, 4th Ed., Prentice-Hall.
1. Hillar G.C. (2017), _Java 9 with JShell_, Packt.
1. Horstmann C. S. (2016), _Core Java, Volume 1 Fundamentals_, 10th Ed., Prentice-Hall.
1. Horstmann C. S. (2018), _Core Java SE 9 for the impatient_, 2nd Ed., Addison-Wesley. 
1. Naftalin M., Wadler P. (2006), _Java Generics and Collections_, O'Reilly. 
1. Sharan K. (2017), _Java 9 Revealed: For Early Adoption and Migration_, Apress.
1. Sierra K. & Bates B. (2005), _Head First Java_, 2nd Ed. for Java 5.0, O’Reilly.
1. [Apache NetBeans](https://netbeans.apache.org/help/index.html)

---

[<-](../2.2-UML/README.md) | [Δ](../../README.md) | [->](../2.4-Inheritance/README.md)

---