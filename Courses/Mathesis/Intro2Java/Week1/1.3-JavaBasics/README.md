# 1.3 Αριθμοί, μεταβλητές, εκφράσεις {#Java} 
© Γιάννης Κωστάρας

---

[<-](../1.2-Installation/README.md) | [∆](../../README.md) | [->](../1.4-Strings/README.md)

---

Σ' αυτό το μάθημα θα κάνουμε τα πρώτα μας βήματα στη γλώσσα προγραμματισμού Java. Η γλώσσα Java αποτελείται από: λέξεις-κλειδιά (keywords), μεταβλητές (variables ή identifiers), σταθερές (constants ή literals), τελεστές (operators) και σημεία στίξης (punctuators).

Οι _λέξεις-κλειδιά (keywords)_ είναι δεσμευμένες λέξεις που αποτελούν τις εντολές της γλώσσας (π.χ. ```int, String, for, public, try```). 

Οι _μεταβλητές (variables ή identifiers)_ είναι, όπως θα δούμε, διευθύνσεις μνήμης για ν' αποθηκεύουμε δεδομένα ή αποτελέσματα πράξεων.

Οι _σταθερές (constants ή literals)_ είναι επίσης θέσεις μνήμης που αποθηκεύουν δεδομένα που δεν μπορούν να μεταβληθούν κατά την εκτέλεση του προγράμματος.

Οι _τελεστές (operators)_ είναι διάφορες πράξεις που υποστηρίζει η γλώσσα (π.χ. ```+, %, ++, && <=```) και χρησιμοποιούνται σε εκφράσεις.

Τα _σημεία στίξης (keywords)_ είναι ειδικοί χαρακτήρες που έχουν ειδικό νόημα για τον μεταγλωττιστή (π.χ. ```; , . { }```).

## Σχόλια

Η Java υποστηρίζει τριών ειδών σχόλια.

Σχόλιο μιας γραμμής:
```java
int radius;          // Αυτό είναι ένα σχόλιο μιας γραμμής

```
Σχόλιο πολλαπλών γραμμών:
```java
/* 
 * Αυτό είναι ένα σχόλιο
 * πολλαπλών γραμμών.
 */
int radius;          
```
Σχόλιο τεκμηρίωσης (Javadoc):
```java
/** 
 * Αυτό είναι ένα σχόλιο
 * τεκμηρίωσης κώδικα (Javadoc).
 */
int radius;          
```
Τα σχόλια Javadoc σας επιτρέπουν να τεκμηριώνετε τον κώδικά σας και να παράγετε τη διεπαφή των κλάσεών σας (Application Program Interface - API) σε μορφή HTML. Π.χ. [εδώ](https://docs.oracle.com/javase/10/docs/api/index.html?overview-summary.html) βλέπετε το API των κλάσεων της Java 10. Θα μάθουμε πώς να γράφουμε τα δικά μας σχόλια Javadoc τη 2η εβδομάδα.

## Αριθμοί

Η Java υποστηρίζει τους παρακάτω αριθμητικού τύπους:

* Ακέραιοι:
  * Δεκαδικός: π.χ. ```15```
  * Οκταδικός: π.χ. ```023```
  * Δεκαεξαδικός: π.χ. ```0xΑΒ```
  * Δυαδικός: π.χ. ```0b101```
  * Αναπαράσταση μεγάλων αριθμών: π.χ. ```123_456_789```

* Πραγματικοί: π.χ. ```3.14```
  * ```125E-3 // 10^-3 = 0.125```
  * ```0x1.0p-3 // 2^-3 = 0.125```

### Αριθμητικοί τύποι δεδομένων
Οι παρακάτω πίνακες δείχνουν τους αριθμητικούς τύπους δεδομένων που υποστηρίζονται από τη γλώσσα καθώς και το εύρος τιμών καθενός από αυτούς.

**Πίνακας 1.3.1** _Ακέραιοι τύποι δεδομένων_

| Τύπος δεδομένων | Αποθηκευτικός χώρος | Εύρος τιμών
| ```byte``` | 1 byte | ```–128 -> 127 (-2^7 to 2^7-1)```
| ```short``` | 2 bytes | ```–32,768 -> 32,767 (-2^15 to 2^15-1)```
| ```int``` | 4 bytes | ```–2,147,483,648 -> 2,147,483,647(-2^31 to 2^31-1)```
| ```long``` | 8 bytes | ```–9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807 (-2^63 to 2^63-1)```

**Πίνακας 1.3.2** _Τύποι δεδομένων κινητής υποδιαστολής σύμφωνα με το πρότυπο ΙΕΕΕ 754_

| Τύπος δεδομένων | Αποθηκευτικός χώρος | Εύρος τιμών
| ```float``` | 4 bytes | ```±3.40282347E+38```
| ```double``` | 8 bytes | ```±1.7976931348623157E+308```

Καλό είναι να χρησιμοποιείτε τον κατάλληλο τύπο δεδομένων ανάλογα με τις ανάγκες του προγράμματός σας. Αν χρησιμοποιήσετε τύπο δεδομένων με πολύ μεγαλύτερο εύρος τιμών από αυτό που χρειάζεται το πρόγραμμά σας, τότε σπαταλάτε άσκοπα μνήμη. Αν από την άλλη, χρησιμοποιήσετε τύπο δεδομένων με μικρότερο εύρος τιμών απ' ότι χρειάζεται το πρόγραμμά σας, τότε κινδυνεύετε να έχετε υπερχήλιση (overflow) και τα αποτελέσματα που θα πάρετε να μην είναι σωστά. 

Μεγάλη προσοχή επίσης στις πράξεις μεταξύ δεδομένων κινητής υποδιαστολής, όπως βλέπετε στο παρακάτω παράδειγμα:
```java
jshell> 2.0d - 2.01d
$1 ==> -0.009999999999999787
```
Λόγω του τρόπου [αναπαράστασής τους](https://en.wikipedia.org/wiki/IEEE_754) από τους Η/Υ, δεν μπορείτε να βασίζεστε στις πράξεις τέτοιων αριθμών. Η Java παρέχει κάποιες κλάσεις ([BigInteger](https://docs.oracle.com/javase/10/docs/api/java/math/BigInteger.html), [BigDecimal](https://docs.oracle.com/javase/10/docs/api/java/math/BigDecimal.html)) γι' αυτό το σκοπό, όπως θα δούμε σε ακόλουθα μαθήματα. Αν θέλετε να συγκρίνετε δυο αριθμούς τύπου ```float``` χρησιμοποιήστε την εντολή ```Float.compare(float,float)``` και για τύπου ```double``` την ```Double.compare(double, double)``` αντίστοιχα. 

### Προτεραιότητα αριθμητικών πράξεων

Η προτεραιότητα των αριθμητικών πράξεων φαίνεται στον ακόλουθο πίνακα (όσο πιο πάνω τόσο μεγαλύτερη η προτεραιότητα).

**Πίνακας 1.3.3** _Προτεραιότητα αριθμητικών πράξεων_

| ```+ -``` | Πρόσημα
| ```()``` | Παρενθέσεις
| ```* / %``` | Πολλ/σμός, Διαίρεση, Υπόλοιπο διαίρεσης ```(a / b) * b + r = a```
| ```+ -``` | Πρόσθεση, Αφαίρεση
| ```< > <= >= == !=``` | Μεγαλύτερο, μικρότερο, μεγαλύτερο ίσο, μικρότερο ίσο, ίσο, άνισο

Π.χ. πόσο κάνει η παρακάτω πράξη:
```java
jshell> 5 + 2 * 4
```
Αν απαντήσατε ```14``` τότε δε λάβατε υπόψιν σας την προτεραιότητα των τελεστών όπως φαίνεται στον παραπάνω πίνακα. Καθώς ο πολλ/σμός (```*```) έχει υψηλότερη προτεραιότητα από την πρόσθεση, θα εκτελεστεί πρώτα και μετά η πρόσθεση. 

Η σωστή απάντηση είναι ```13```.

## Λογικοί τύποι δεδομένων και λογικές πράξεις

**Πίνακας 1.3.4** _Λογικός τύπος δεδομένων_

| Τύπος δεδομένων | Αποθηκευτικός χώρος | Εύρος τιμών
| boolean | 1 byte | ```true,false```

**Πίνακας 1.3.5** _Λογικές πράξεις_

| ```!``` | Όχι (Not)
| ```&&, ||``` | Λογικό ΚΑΙ (And), Ή (Or)
| ```&, |``` | Λογικό ΚΑΙ (And), Ή (Or)

Παρακάτω φαίνονται οι πίνακες αληθείας των πράξεων αυτών (F: Ψευδής, T: Αληθής):

| ```x``` | ```~x``` |
| F | T |
| T | F |

| ```x``` | ```y``` | ```x && y``` ή ```x & y```
| F | F | F
| F | T | F
| T | F | F
| T | T | T

| ```x``` | ```y``` | ```x || y``` ή ```x | y```
| F | F | F
| F | T | T
| T | F | T
| T | T | T


Όπως παρατηρείτε, υπάρχουν δυο είδη λογικών τελεστών για το λογικό ΚΑΙ και το λογικό Ή. Η διαφορά τους είναι η εξής:

* Οι λογικοί τελεστές ```&&, ||```, ή τελεστές συνθήκης, ελέγχουν το 2ο όρισμα μόνο αν δεν μπορούν να συνάγουν αποτέλεσμα από το πρώτο μόνο όρισμα. Π.χ. στη συνθήκη ```x && y```, αν το ```x == false``` τότε δεν ελέγχεται το δεύτερο όρισμα καθώς γνωρίζουμε ήδη ότι η τιμή της συνθήκης είναι ```false```
* Οι λογικοί τελεστές ```&, |```, ή δυαδικοί τελεστές, ελέγχουν πάντα και τα δυο ορίσματα

Αυτό πολλές φορές μπορεί ν' αποτελέσει πηγές λάθους (bugs). Π.χ. στο παρακάτω παράδειγμα (που χρησιμοποιεί πίνακες ή συστοιχίες για τις οποίες θα μιλήσουμε σε επόμενο μάθημα αυτής της εβδομάδας), ο πίνακας ```array``` μπορεί να έχει τιμή ```null```, αλλά επειδή χρησιμοποιείται ο τελεστής ```&``` αντί για τον ```&&```, ελέγχονται όλες οι παραμέτροι με αποτέλεσμα π.χ. η ```array.lenght``` να επιστρέφει λάθος εκτέλεσης καθώς προσπαθούμε να καλέσουμε τη μέθοδο ```length``` στην ```array``` που είναι ```null```.

```java
if (array != null & i >= 0 & i < array.length) {
	// ...
} else {
	// ...
}
```

## Δυαδικές πράξεις

**Πίνακας 1.3.6** _Δυαδικές πράξεις_

| ```~``` | Όχι (Not)
| ```&, |, ^``` | Λογικό ΚΑΙ (And), Ή (Or), Xor
| ```<<, >>, >>>``` | Αριστερή, δεξιά ολίσθηση (Πολλ/σμός επί, διαίρεση με δύναμη του 2) 

Παρακάτω φαίνονται οι πίνακες αληθείας των πράξεων αυτών (F: Ψευδής, T: Αληθής):

| ```x``` | ```~x``` |
| F | T |
| T | F |

| ```x``` | ```y``` | ```x & y```
| F | F | F
| F | T | F
| T | F | F
| T | T | T

| ```x``` | ```y``` | ```x | y```
| F | F | F
| F | T | T
| T | F | T
| T | T | T

| ```x``` | ```y``` | ```x ^ y```
| F | F | F
| F | T | T
| T | F | T
| T | T | F

```java
jshell> int i=0
i ==> 0         // 00000000
jshell> ~i
$6 ==> -1		// 11111111
jshell> (~i)+1	// 100000000  υπερχείλιση (overflow)
$7 ==> 0 		// 00000000
```

Οι τελεστές ολίσθησης ολισθαίνουν κατά ένα ή περισσότερα bits την αναπαράσταση ενός αριθμού αριστερά ή δεξιά. Η διαφορά των δυο δεξιών τελεστών ολίσθησης είναι η εξής: 

* ```>>>``` (γεμίζει με 0)        
* ```>>``` (γεμίζει με το πιο αριστερό bit)  

Παραδείγματα χρήσης τελεστών ολίσθησης:

```java
0b0000000000001011 << 1   -> 0b0000000000010110  // 11 << 1  ==> 22  αριστερή ολίσθηση <=> πολλ/σμός επί 2
0b0000000000001011 >> 1   -> 0b0000000000000101  // 11 >> 1  ==> 5   δεξιά ολίσθηση <=> διαίρεση επί 2
0b0000000000001011 >>> 1  -> 0b0000000000000101  // 11 >> 1  ==> 5   δεξιά ολίσθηση <=> διαίρεση επί 2
                          
0b1000000000001011 << 1   -> 0b0000000000010110  // 32779 << 1   ==> 65558   αριστερή ολίσθηση <=> πολλ/σμός επί 2
0b1000000000001011 >> 1   -> 0b1100000000000101  // 32779 >> 1   ==> 16389   δεξιά ολίσθηση <=> διαίρεση επί 2
0b1000000000001011 >>> 1  -> 0b0100000000000101  // 32779 >>> 1  ==> 16389   δεξιά ολίσθηση <=> διαίρεση επί 2
```

Ας δούμε μερικά παραδείγματα πράξεων δυαδικών αριθμών:

```java
jshell> byte x=0b10
x ==> 2
jshell> Integer.toBinaryString(x<<1)
$1 ==> "100" // 4 = 2*2
jshell> Integer.toBinaryString(x>>1)
$2 ==> "1"   // = 2/2
jshell> byte y=0b11
y ==> 3
jshell> Integer.toBinaryString(x&y) // ΚΑΙ
$3 ==> "10"
jshell> Integer.toBinaryString(x|y) // Ή
$4 ==> "11"
jshell> Integer.toBinaryString(x^y) // XOR
$5 ==> "01"
```

| ```x``` | 10 |
| ```y``` | 11 |
| ```x & y``` | 10 |
| ```x | y``` | 11 |
| ```x ^ y``` | 01 |

## Τύπος δεδομένων χαρακτήρας

**Πίνακας 1.3.7**  _Τύπος δεδομένων χαρακτήρας_

| Τύπος δεδομένων | Αποθηκευτικός χώρος | Εύρος τιμών
| ```char``` | 2 bytes (16-bit Unicode) | ```'\u0000' - '\uffff'```

**Πίνακας 1.3.8** _Πράξεις_

| ```+``` | ```char``` μετατρέπεται σε ```int```

Οι χαρακτήρες αναπαρίστανται στους Η/Υ ως δυαδικοί αριθμοί. Υπάρχουν διάφορα πρότυπα αναπαράστασης χαρακτήρων στους Η/Υ έτσι ώστε να αναπαρίστανται με τον ίδιο κωδικό. Το πιο γνωστό τέτοιο πρότυπο είναι ο κώδικας [ASCII](http://www.asciitable.com/).

```java
jshell> char char1 = 'α'
char1 ==> 'α’
jshell> char char2 = 'γ'
char2 ==> 'γ’
jshell> char char3 = char1 + char2
|  Error:
|  incompatible types: possible lossy conversion from int to char
|  char char3 = char1 + char2;
|               ^-----------^
jshell> int char3 = char1 + char2
char3 ==> 1892
jshell> int char1 = 'α'
char1 ==> 945
jshell> char char1 = 945
char1 ==> 'α'
```

## Μετατροπές τύπων δεδομένων (casting)

Μερικές φορές είναι απαραίτητο να μετατρέψετε μια μεταβλητή ενός τύπου δεδομένων σ' έναν άλλον, όπως φαίνεται στο ακόλουθο σχήμα:

![](assets/Fig1.png)

**Εικόνα 1.3.1** _Διάγραμμα μετατροπών τύπων δεδομένων_

* ```--->``` δηλώνει ότι μπορεί να χαθεί ακρίβεια

Όταν η μετατροπή γίνεται σε κάποιον τύπο δεδομένων μεγαλύτερης χωρητικότητας, δεν υπάρχει πρόβλημα, όταν όμως γίνεται σε κάποιον τύπο δεδομένων μικρότερης χωρητικότητας, τότε μπορεί να χαθεί ακρίβεια με ίσως λάθος αποτελέσματα. 

Η σύνταξη μετατροπής σε άλλον τύπο δεδομένων (casting) γίνεται ορίζοντας τον νέο τύπο δεδομένων μέσα σε παρενθέσεις μπροστά από το δεδομένο. Στο παρακάτω παράδειγμα βλέπουμε πώς μπορεί να χαθεί ακρίβεια κάνοντας casting ενός ακέραιου αριθμού σε byte (το byte μπορεί να πάρει τιμή μέχρι το 127): 

```java
jshell> (byte)260
$1 ==> 4 
```

Ας δούμε άλλο ένα παράδειγμα. Τι επιστρέφει η παρακάτω ακολουθία μετατροπών;

```java
jshell> (int) (char) (byte) -1
$2 ==> 65535
```
αντί για ```-1```! Η μετατροπή ```(byte) -1``` μετατρέπει τον ακέραιο ```-1``` σε ```byte``` (32 bits -> 8 bits). Η 2η μετατροπή μετατρέπει το ```byte``` σε ```char``` (8 bits -> 16 bits). Η τρίτη μετατρέπει το ```char``` σε ```int``` (16 bits -> 32 bits). Η μετατροπή ```int -> byte``` αφήνει τον ```-1``` αμετάβλητο. Η μετατροπή όμως ```byte -> char``` όχι, γιατί ο τύπος δεδομένων ```char``` είναι απρόσημος (```0 - 2^16-1```), με αποτέλεσμα ο ```-1``` να μετατρέπεται στον ```2^16-1``` ή ```65535```:

```java
jshell> Integer.toBinaryString(-1)
$3 ==> "11111111111111111111111111111111"

jshell> Integer.toBinaryString((int) (char) (byte) -1)
$4 ==> "1111111111111111"
```


## Μεταβλητές
Τα δεδομένα που χρησιμοποιούμε στα προγράμματά μας αποθηκεύονται στη μνήμη του Η/Υ και καλούνται από την Κ.Μ.Ε. για επεξεργασία. Η μνήμη του υπολογιστή μπορεί να θεωρηθεί ως ένας μεγάλος μονοδιάστατος πίνακας από bytes, όπως φαίνεται στο ακόλουθο σχήμα.

![](assets/Fig2.png)

**Εικόνα 1.3.2** _Αναπαράσταση της κύριας μνήμης του Η/Υ ως μονοδιάστατος πίνακας από bytes_

Για πολλούς λόγους (π.χ. ασφάλειας) δεν μπορούμε να έχουμε άμεση πρόσβαση σε μια διεύθυνση μνήμης. Αντιθέτως, πρόσβαση στη μνήμη μας παρέχει η γλώσσα προγραμματισμού μέσω κλήσεων του Λ.Σ. Πώς όμως μπορούμε να προσπελάσουμε τη θέση μνήμης που μας παρείχε το Λ.Σ.; Αυτό γίνεται μέσω των μεταβλητών. Οι μεταβλητές είναι ονόματα που η γλώσσα προγραμματισμού αντιστοιχίζει με τη βοήθεια του Λ.Σ. σε κάποια φυσική διεύθυνση μνήμης. 

Το όνομα μιας μεταβλητής μπορεί να περιλαμβάνει λατινικούς χαρακτήρες ```a..Z, A..Z``` αριθμούς ```0..9, $``` και ```_```. Δεν μπορεί να αρχίζει όμως με αριθμητικό ψηφίο ούτε μπορεί να είναι δεσμευμένη λέξη (δηλ. κάποια από τις εντολές) της γλώσσας.

Επίσης, ο τύπος δεδομένων που διαλέξαμε για να ορίσουμε μια μεταβλητή λέει στη Java πόσες θέσεις μνήμης να δεσμεύσει γι' αυτή τη μεταβλητή (ανάλογα με το εύρος τιμών του τύπου δεδομένων). Π.χ. για έναν ακέραιο δεσμεύονται 4 bytes συνεχόμενων θέσεων μνήμης.

Π.χ.
```java
int myVar;    // ορισμός μια νέας μεταβλητής με όνομα myVar τύπου int
```
Μπορείτε ν' αρχικοποιήσετε μια μεταβλητή τη στιγμή του ορισμού της:
```
Τύπος_μεταβλητής όνομα_μεταβλητής = έκφραση
```
Π.χ.
```java
int x = 3;
int y = 5*x*x-2;        // y=5∙x^2-2 
jshell> /vars
```

**Πίνακας 1.3.10** _Προτεραιότητα αριθμητικών πράξεων_

| ```+ -``` | Πρόσημα
| ```++ --``` | προσαύξηση, προσαφαίρεση (προθεματικός, επιθεματικός)
| ```(cast)``` | Μετατροπή δεδομένων
| ```!``` | Λογικό ΟΧΙ
| ```()``` | Παρενθέσεις
| ```* / %``` | Πολλ/σμός, Διαίρεση, Υπόλοιπο διαίρεσης (a / b) * b + r = a
| ```+ -``` | Πρόσθεση, Αφαίρεση
| ```< > <= >= == !=``` | Μεγαλύτερο, μικρότερο, μεγαλύτερο ίσο, μικρότερο ίσο, ίσο, άνισο

**Πίνακας 1.3.11** _Τελεστές καταχώρησης_

| ```= += -= *= /= %= ++ -- <<= >>= >>>= &= |= ^=``` | 

```java
int x = 3;
int answer = x++ * 10;  // answer = 30, x = 4
x = 3;
answer = ++x * 10;      // answer = 40, x = 4
```

Όπως είδαμε στο πρώτο μάθημα αυτής της εβδομάδας, η Java είναι μια στατική γλώσσα προγραμματισμού, πράγμα που σημαίνει ότι πρέπει να ορίζουμε εξ' αρχής τον τύπο δεδομένων μιας μεταβλητής. Από την έκδοση 10 όμως και μετά, η γλώσσα υποστηρίζει τη λέξη κλειδί ```var``` με την οποία μπορούμε να ορίζουμε τοπικές μεταβλητές χωρίς να δηλώνουμε τον τύπο τους και ο μεταγλωττιστής μπορεί να συνάγει (infer) τον τύπο δεδομένων από την αρχική τιμή τους, π.χ.

```
jshell> var i = 0;
i ==> 0

jshell> ++i
$1 ==> 1
```

_Σημείωση:_ Η ```var``` είναι ανάλογη της ```auto``` της C++11. 
_Σημείωση:_ Η ```var``` _δεν_ είναι λέξη κλειδί της γλώσσας! Ο μεταγλωττιστής δεν παραπονιέται αν γράψουμε ```var var = 42;```.

## Σταθερές
Ενώ οι μεταβλητές μπορούν ν' αλλάξουν την τιμή τους κατά τη διάρκεια εκτέλεσης του προγράμματος, αυτό δεν μπορεί να γίνει με τις σταθερές. Ορίζετε μια σταθερά με τη λέξη ```final```:
```java
final double PI = 3.14159; 
final int ARRAY_SIZE = 100;
PI = 4;
```

## Ασκήσεις
1. Ποιοι από τους παρακάτω είναι αποδεκτοί αριθμοί; 
* ```1_2_3               ```
* ```3.14F               ```
* ```3.14_F              ```
* ```3._14               ```
* ```3_.14               ```
* ```.0                  ```
* ```0.                  ```
* ```0b0_1_0_1           ```
* ```0100                ```
* ```0xABCD              ```
* ```0_xFFFF             ```
* ```_123                ```
* ```123_                ```
* ```1E-1D               ```
* ```1.0e10f             ```
2. Ποια από τα παρακάτω είναι αποδεκτά ονόματα μεταβλητών; 
* ```a12345            ```
* ```_12345            ```
* ```_abcd             ```
* ```12345_            ```
* ```$12               ```
* ```high-score        ```
* ```_                 ```
3. Να ανταλλάξετε τις τιμές δυο μεταβλητών ```a``` και ```b```. Π.χ. αν ```a = 3``` και ```b = 4``` τότε μετά την εκτέλεση του προγράμματός σας ```a = 4``` και ```b = 3```.
4. Να μετατρέψετε μια θερμοκρασία από βαθμούς Φαρενάιτ σε βαθμούς Κελσίου 
5. Να υπολογίσετε τον ετήσιο φόρο που θα πληρώσει κάποιος που παίρνει μισθό 800 ευρώ το μήνα και η κλίμακα φορολόγησης είναι 50%
6. Υπολογίστε αν ένα έτος είναι δίσεκτο. Ένα έτος είναι δίσκεκτο αν διαιρείται με το 4 αλλά όχι με το 100 ή διαιρείται με το 400. 
7. Πώς μπορούμε να ελέγξουμε αν ένας αριθμός είναι δύναμη του 2 χρησιμοποιώντας μόνο πράξεις bit;

## Πηγές:
1. ["The Java Tutorial"](https://docs.oracle.com/javase/tutorial/)
1. Bloch J. (2018), _Effective Java_, 3rd Edition, Addison-Wesley.
1. Deitel P., Deitel H. (2018), _Java How to Program_, 11th Ed., Safari.
1. Downey A. B., Mayfield C. (2016), _Think Java_, O' Reilly. 
1. Eckel B. (2006), _Thinking in Java_, 4th Ed., Prentice-Hall.
1. Kabutz H. (2018). "Java 10: Inferred Local Variables", _JavaSpecialists Newsletter_, [Issue 255](https://www.javaspecialists.eu/archive/Issue255.html)
1. Hillar G.C. (2017), _Java 9 with JShell_, Packt.
1. Horstmann C. S. (2016), _Core Java, Volume 1 Fundamentals_, 10th Ed., Prentice-Hall.
1. Horstmann C. S. (2018), _Core Java SE 9 for the impatient_, 2nd Ed., Addison-Wesley. 
1. Liguori R. & Liguori P. (2014), _Java 8 Pocket Guide_, O'Reilly.
1. Long F. et. al. (2014), _Java Coding Guidelines_, Addison-Wesley.
1. Samoylov N. (2019), _Learn Java 12 Programming_, Packt.
1. Sharan K. (2017), _Java 9 Revealed: For Early Adoption and Migration_, Apress.
1. Sierra K. & Bates B. (2005), _Head First Java_, 2nd Ed. for Java 5.0, O’Reilly.

---

[<-](../1.2-Installation/README.md) | [∆](../../README.md) | [->](../1.4-Strings/README.md)

---